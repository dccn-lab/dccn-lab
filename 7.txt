#include <stdio.h>
#include <stdlib.h>

#define NUL 1000
#define NODES 10

struct node {
    int t[NODES][3];
};

struct node n[NODES];
typedef struct node NOD;

void init(int no, int x);
void inp(int no, int x);
void caller(int no, int x);
void op1(int no, int x, int z);
void find(int x, int y);

int main() {
    int i, j, x, y, no;

    do {
        printf("\n Enter the no of nodes required: ");
        scanf("%d", &no);
    } while (no > 10 || no < 0);

    for (i = 0; i < no; i++) {
        init(no, i);
        inp(no, i);
    }

    printf("\nThe configuration of the nodes after initialization is as follows:");
    for (i = 0; i < no; i++)
        op1(no, i, 0);

    for (j = 0; j < no; j++) {
        for (i = 0; i < no; i++)
            caller(no, i);
    }

    printf("\nThe config of the nodes after the comp of the paths is as follows:");
    for (i = 0; i < no; i++)
        op1(no, i, 1);

    while (1) {
        printf("\n Enter 0 to exit or any other key to find the shortest path: ");
        scanf("%d", &j);
        if (!j) break;

        do {
            printf("\n Enter the nodes btn which path is to be found: ");
            scanf("%d %d", &x, &y);
        } while ((x < 0 || x > no) || (y < 0 || y > no));

        printf("\nThe most suitable route from node %d to %d is as follows\n", x, y);
        find(x, y);
        printf("%d", y);

        printf("\nThe length of the shortest path between node %d & %d is %d",
               x, y, n[x-1].t[y-1][2]);
    }

    return 0;
}

void init(int no, int x) {
    int i;
    for (i = 0; i < no; i++) {
        n[x].t[i][0] = x;
        n[x].t[i][1] = i;
        if (x == i)
            n[x].t[i][2] = 0;
        else
            n[x].t[i][2] = 999;
        n[x].t[i][3] = NUL;
    }
}

void inp(int no, int x) {
    int i;
    for (i = 0; i < no; i++) {
        if (i != x) {
            printf("\nEnter distance from node %d to node %d (999 for no link): ",
                   x+1, i+1);
            scanf("%d", &n[x].t[i][2]);
            if (n[x].t[i][2] != 999)
                n[x].t[i][3] = i;
        }
    }
}

void caller(int no, int x) {
    int i;
    for (i = 0; i < no; i++)
        ;
    for (i = 0; i < no; i++) {
        int y = n[x].t[i][3];
        if (y >= 0 && y < no) {
            int z = n[x].t[y][2] + n[y].t[i][2];
            if (z < n[x].t[i][2]) {
                n[x].t[i][2] = z;
                n[x].t[i][3] = y;
            }
        }
    }
}

void op1(int no, int x, int z) {
    int i;
    printf("\n The routing table for node no %d is as follows", x+1);
    printf("\n\n\tDESTINATION\tDISTANCE\tNEXT_HOP");

    for (i = 0; i < no; i++) {
        if (n[x].t[i][2] >= 999) {
            printf("\n\t   %d\tNO LINK\tNO HOP", n[x].t[i][1] + 1);
        } else if (n[x].t[i][3] == NUL) {
            printf("\n\t   %d\t   %d\tNO HOP", n[x].t[i][1] + 1, n[x].t[i][2]);
        } else {
            printf("\n\t   %d\t   %d\t   %d",
                   n[x].t[i][1] + 1,
                   n[x].t[i][2],
                   n[x].t[i][3] + 1);
        }
    }
}

void find(int x, int y) {
    int i = x - 1;
    int j = y - 1;
    printf("%d->", x);

    if (n[i].t[j][3] != j) {
        find(n[i].t[j][3] + 1, y);
        return;
    }
}
